#!/usr/bin/env python3
import argparse
import json
import openai
import os
import readline
from dataclasses import dataclass
from openai import OpenAI
from openai.types.chat.chat_completion_message_param import ChatCompletionMessageParam
from pathlib import Path
from rich.console import Console
from rich.live import Live
from rich.markdown import Markdown
from typing import Iterable, List

MODELS = (
    "gpt-4o-mini",
    "gpt-4o",
    "o1-mini",
)

SAVE_DIR = Path.home() / ".oai"

CLI_PROMPT = ">>> "
MULTI_LINE_INPUT = '"""'


@dataclass
class Settings:
    model: str
    pretty: bool


def send(
    client: OpenAI, settings: Settings, messages: Iterable[ChatCompletionMessageParam]
):
    stream = client.chat.completions.create(
        messages=messages,
        model=settings.model,
        stream=True,
    )

    content = ""
    if settings.pretty:
        with Live(console=Console(), refresh_per_second=8) as live:
            for chunk in stream:
                if chunk.choices[0].delta.content is not None:
                    content += chunk.choices[0].delta.content
                    live.update(Markdown(content))
    else:
        for chunk in stream:
            if chunk.choices[0].delta.content is not None:
                chunk_content = chunk.choices[0].delta.content
                print(chunk_content, end="")
                content += chunk_content
        print()
    return content


def get_api_key():
    api_key = os.getenv("OPENAI_API_KEY")
    if api_key is None:
        raise RuntimeError("OPENAI_API_KEY environment variable is not set")
    return api_key


def get_user_input():
    user_input = input(CLI_PROMPT).strip()
    if user_input.startswith(MULTI_LINE_INPUT):
        lines = [user_input[len(MULTI_LINE_INPUT) :]]
        while True:
            line = input().rstrip()
            if line.endswith(MULTI_LINE_INPUT):
                lines.append(line[: -len(MULTI_LINE_INPUT)])
                break
            lines.append(line)
        user_input = "\n".join(lines).strip()
    return user_input.strip()


def print_help():
    print(
        "Available Commands:\n"
        "  /clear            Clear session context\n"
        "  /list             List available models\n"
        "  /select <model>   Select a model\n"
        "  /save <file>      Save conversation to a file\n"
        "  /load <file>      Load conversation from a file\n"
        "  /bye              Exit\n"
        "  /?, /help         Print available commands\n"
        "\n"
        'Use """ to begin a multi-line message.'
    )


def print_models(settings: Settings):
    print("Available models:")
    for model in sorted(MODELS):
        if model == settings.model:
            print(f" * {model}")
        else:
            print(f"   {model}")


def select_model(user_input: str, settings: Settings):
    parts = user_input.split()
    if len(parts) != 2:
        print("Usage:\n  /select <model>")
        return
    model = parts[1]
    if model not in MODELS:
        model_list = ", ".join(MODELS)
        print(f"Unknown model: '{model}'. Available models: {model_list}")
        return
    settings.model = model


def save_conversation(user_input: str, conversation: List[ChatCompletionMessageParam]):
    parts = user_input.split()
    if len(parts) != 2:
        print("Usage:\n  /save <file>")
        return
    filename = parts[1]
    if not filename.endswith(".json"):
        filename += ".json"
    path = SAVE_DIR / filename

    if not conversation:
        print("No conversation to save.")
        return

    if path.exists():
        response = input(f"File '{path}' already exists. Overwrite? (y/n) ").strip()
        if response.lower() != "y":
            return

    if not SAVE_DIR.exists():
        SAVE_DIR.mkdir(parents=True, exist_ok=True)
    with open(path, "w") as save_file:
        json.dump(conversation, save_file, indent=4)
    print(f"\nSaved conversation to '{path}'.")


def load_conversation(
    user_input: str, conversation: List[ChatCompletionMessageParam], settings: Settings
):
    parts = user_input.split()
    if len(parts) != 2:
        print("Usage:\n  /load <file>")
        return
    filename = parts[1]
    if not filename.endswith(".json"):
        filename += ".json"

    path = SAVE_DIR / filename
    if not path.exists():
        print(f"File '{path}' does not exist.")
        return

    if conversation:
        response = input("Overwrite current conversation? (y/n) ").strip()
        if response.lower() != "y":
            return

    with open(path) as save_file:
        saved_conversation = json.load(save_file)

    conversation.clear()
    conversation.extend(saved_conversation)
    print_conversation(conversation, settings)


def print_conversation(
    conversation: List[ChatCompletionMessageParam], settings: Settings
):
    if not conversation:
        return
    for message in conversation:
        role = message["role"]
        content = message["content"]

        if role == "user":
            print(f"\n{CLI_PROMPT}{content}")
        else:
            if settings.pretty:
                Console().print(Markdown(content))
            else:
                print(content)


def handle_command(
    user_input: str, conversation: List[ChatCompletionMessageParam], settings: Settings
):
    command = user_input.split()[0]
    if user_input.startswith("/bye"):
        raise EOFError
    elif user_input.startswith("/clear"):
        conversation.clear()
        print("Cleared conversation.")
    elif user_input.startswith("/list"):
        print_models(settings)
    elif user_input.startswith("/load"):
        load_conversation(user_input, conversation, settings)
    elif user_input.startswith("/save"):
        save_conversation(user_input, conversation)
    elif user_input.startswith("/select"):
        select_model(user_input, settings)
    elif user_input.startswith("/?") or user_input.startswith("/help"):
        print_help()
    elif user_input.startswith("/"):
        command = user_input.split()[0]
        print(f"Unknown command: '{command}'. Type /? for help.")
    print()


def input_loop(client: OpenAI, settings: Settings):
    conversation = []

    readline.parse_and_bind("set editing-mode emacs")

    while True:
        try:
            user_input = get_user_input().strip()
            if not user_input:
                continue
            if user_input.split()[0].startswith("/"):
                handle_command(user_input, conversation, settings)
                continue
        except EOFError:
            break

        conversation.append(
            {
                "role": "user",
                "content": user_input,
            }
        )

        try:
            reply = send(client, settings, conversation)
        except openai.OpenAIError as e:
            print(e)
            print()
            continue

        conversation.append(
            {
                "role": "assistant",
                "content": reply,
            }
        )

        print()


def main():
    parser = argparse.ArgumentParser(
        description="Chat with OpenAI LLMs in the terminal",
        formatter_class=argparse.ArgumentDefaultsHelpFormatter,
    )
    parser.add_argument(
        "--model", default="gpt-4o-mini", choices=MODELS, help="the OpenAI model to use"
    )
    parser.add_argument("--pretty", action="store_true", help="pretty print responses")
    args = parser.parse_args()
    input_loop(OpenAI(api_key=get_api_key()), Settings(args.model, args.pretty))


if __name__ == "__main__":
    main()
